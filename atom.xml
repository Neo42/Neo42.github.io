<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>墨石 🛠</title>
  
  <subtitle>Not only how, but why.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://neo42.github.io/"/>
  <updated>2020-01-30T08:12:50.696Z</updated>
  <id>http://neo42.github.io/</id>
  
  <author>
    <name>墨石</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>严格模式的作用</title>
    <link href="http://neo42.github.io/2020/01/30/2020-1-30-strict-mode/"/>
    <id>http://neo42.github.io/2020/01/30/2020-1-30-strict-mode/</id>
    <published>2020-01-29T16:00:00.000Z</published>
    <updated>2020-01-30T08:12:50.696Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Strict mode finally debunked! Well, for me, at least.</p></blockquote><a id="more"></a><p>严格模式可以“屏蔽”JavaScript 语言在使用中容易引起 bug 的功能，禁止出现不符合规范的代码，从而让 JS 的编译器更高效地运行。</p><ul><li>变量被声明时必须被赋值。</li><li>函数参数必须具有唯一名称（否则会被视为语法错误）</li><li>禁止使用 <code>with</code>。</li><li>只读属性被赋值时会报错。</li><li>像 <code>00840</code> 这样的八进制数字报语法错误。</li><li>尝试 <code>delete</code> 不可删除的属性会引发语法错误。</li><li><code>delete prop</code> 会报错， <code>delete global [prop]</code> 不会。</li><li><code>eval</code> 不会将新变量引入其所在作用域。</li><li><code>eval</code> 和参数不能被绑定或赋值。</li><li><code>arguments</code> 不会跟踪方法参数的变更。</li><li><code>arguments.callee</code> 引发 TypeError，不再支持。</li><li><code>arguments.caller</code> 引发 TypeError，不再支持。</li><li>方法被调用时作为<code>this</code>传入方法的上下文不会变成对象。</li><li>JavaScript 堆栈不能通过使用 <code>fn.caller</code> 和 <code>fn.arguments</code> 访问 。</li><li>保留字（例如 <code>protected</code>、<code>static</code>、<code>interface</code> 等）无法被赋值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Strict mode finally debunked! Well, for me, at least.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【译】可变变量 - MDN Web 名词解释</title>
    <link href="http://neo42.github.io/2019/10/14/2019-10-14-mdn-mutable/"/>
    <id>http://neo42.github.io/2019/10/14/2019-10-14-mdn-mutable/</id>
    <published>2019-10-13T16:00:00.000Z</published>
    <updated>2019-10-14T12:15:38.235Z</updated>
    
    <content type="html"><![CDATA[<p>可变变量是一种可以被修改的变量。在 JavaScript 中，只有对象和数组是可变的，原始类型不是。</p><p>（您可以使变量名称指向一个新值，但先前的值仍保留在内存中。因此需要进行垃圾回收。）</p><p>可变对象是一旦创建即可修改其状态的对象。</p><p>不可变对象是一旦创建便无法更改其状态的对象。</p><p>字符串和数字是不可变的。我们用一个例子来理解这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> immutableString =“ Hello”;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们上面的代码中创建了一个带有字符串值的新对象。</span></span><br><span class="line"></span><br><span class="line">immutableString = immutableString + <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在，我们将 “World” 附加到现有值上。</span></span><br></pre></td></tr></table></figure><p>在将“ immutableString”附加到字符串值后，将发生以下事件：</p><ol><li>检索<code>immutableString</code>的现有值</li><li>“World” 被附加到<code>immutableString</code>的现有值之后</li><li>结果值被分配给新的内存块</li><li><code>immutableString</code>对象指向新创建的内存空间</li><li>以前创建的内存空间现在可以被垃圾回收了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可变变量是一种可以被修改的变量。在 JavaScript 中，只有对象和数组是可变的，原始类型不是。&lt;/p&gt;
&lt;p&gt;（您可以使变量名称指向一个新值，但先前的值仍保留在内存中。因此需要进行垃圾回收。）&lt;/p&gt;
&lt;p&gt;可变对象是一旦创建即可修改其状态的对象。&lt;/p&gt;
&lt;p&gt;不可
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>尝试理解Redux</title>
    <link href="http://neo42.github.io/2019/09/18/2019-9-5-tap-into-redux/"/>
    <id>http://neo42.github.io/2019/09/18/2019-9-5-tap-into-redux/</id>
    <published>2019-09-17T17:36:59.375Z</published>
    <updated>2019-09-17T17:36:59.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在 Redux，光听别人讲总觉得半懂不懂，也很难记住，干脆自己试着写篇东西梳理一下。但在学习 Redux 之前，我们有必要明白 Redux 是什么、有什么用。官方对于 Redux 的定义是个不错的入手点。</p></blockquote><a id="more"></a><blockquote><p><strong>Redux 是一个 JavaScript 应用的可预测的状态容器。</strong></p></blockquote><p>乍看这句话还挺难懂的，我们可以把这句话拆开来理解。这句话其实是对 Redux 的作用做了个总结。换句话说，我们可以把这个定义看作是官方对于这个问题 的解答：</p><blockquote><p>Redux 要（尝试）解决谁的什么问题？它是怎么（尝试）去解决的？</p></blockquote><ul><li>谁的问题 —— JavaScript 应用</li><li>什么问题 —— 状态（管理）</li><li>怎么解决 —— （状态）可预测、容器</li></ul><p><strong>JavaScript 应用</strong></p><p>Javascript 应用这个概念，写过 <code>console.log(&#39;Hello World&#39;)</code> 的应该都理解是什么意思，所以它的含义我就不赘述了。但值得注意的是，这里的 Javascript 应用<strong>包括且不限于 React 应用</strong>，也就是说 Redux 不止可以和 React 合用，还可以跟其他框架、库甚至原生 JS 合用。</p><p><strong>状态(管理)</strong></p><!-- 可预测、JavaScript 应用、状态、容器。 --><p><strong>首先，什么是状态？</strong>各位学过 React 的应该都知道 State 和 Props 的概念。然而尽管这两个词看起来好像挺熟悉，但要是真的让你解释二者的区别，似乎也不太容易。这里不妨把 Props 和 State 做个对比，以便理解。</p><p>先来看几句话。</p><blockquote><p>一句话概括，props 是组件对外的接口，state 是组件对内的接口。<div style="text-align: right">—— 徐超<a href="https://book.douban.com/subject/30210697/" target="_blank" rel="noopener">《React 进阶之路》</a> </div></p><p>React 组件中的 props 是其父组件传入的变量。而 state 也是变量，不过是直接在组件内初始化而且受组件自身管理。<div style="text-align: right">—— <a href="https://twitter.com/flaviocopes" target="_blank" rel="noopener">Flavio Copes</a></div></p><p>“props”(property 的简写)是一个外界任意输入的对象，被 React 函数组件作为第一个参数接收。“state”是随着某一 React 组件的生命周期变化的数据。<div style="text-align: right">—— <a href="https://twitter.com/kentcdodds" target="_blank" rel="noopener">Kent C Dodds</a></div></p><p>用 state 储存你当前的页面在控制器-视图中所需的数据；用 props 把数据和事件监听器向下传入你的子组件。<div style="text-align: right">——<a href="https://stackoverflow.com/questions/27991366/what-is-the-difference-between-state-and-props-in-react/32186324#32186324" target="_blank" rel="noopener">StackOverflow</a></div></p></blockquote><p>可见，Props 通常与父子组件的沟通有关，而 state 与组件自身有关。React 官方文档中当然也有介绍 props 和 state，在讲解这两个概念时，文档并没有单独去分别解释 props 和 state 是什么意思，而是各自搭配了一个概念。props 搭配 component，state 则搭配 lifecycle。这样，两者的关系就清楚了。</p><p>先说状态：</p><ul><li>状态就是组件自身所需的、储存在组件内部的数据。</li><li>状态是可变的，但只能在组件内部进行修改而不能从外部被修改。</li><li>状态会随着某一组件实例的生命周期不断变化。</li><li>与 props 相比性能较差。</li></ul><p>另一方面，props 是这样的：</p><ul><li>props 通常是外界（父组件、用户等）传入的数据。</li><li>不可变。这一点使 React 能够快速检查引用（reference）。</li><li>性能较好。所以被作为一般父组件向子组件传入沟通数据和事件监听器的方式。</li></ul><p>理解了 state 和 props 的各自的含义和区别，我们自然可以问出这个问题。</p><blockquote><p><strong>什么样的组件应该使用状态呢？</strong></p><p><strong>包含负责响应用户输入、服务器请求逻辑的组件。</strong>其实应用中的大部分组件只需要接收、渲染数据就可以了，所以很多开发者都倾向于把这部分组件写成无状态的函数组件，而把状态用于内部包含逻辑的少数几个组件里，这样也可以简化代码的理解难度。状态里储存的数据应该是随着用户交互、服务器请求等事件变化从而引发 UI 变更的数据。</p></blockquote><p>再接下来，<strong>状态管理为什么会成为问题？</strong></p><p>要回答这个问题我们还是应该从状态变化的原因上来找答案。</p><p>在现在前端工程中，一个应用，尤其是一个单页应用的状态很容易就变得非常复杂。传统架构中的状态数据的流动是在视图（view）和模型（model）或视图与视图之间直接进行的。状态中的一部分会通过 Ajax 或者 Websocket 到达前端，而很多状态跟后端服务器并没有关系。很多状态会在各个组件中<strong>共享、传递</strong>（比如 MVC 架构）。组件间的复杂关系导致<strong>应用状态数据支离破碎，缺少一个统一的分配方式</strong>。另一个问题是状态在组件之间的多层渗透会导致<strong>渲染成本增加、效率下降</strong>，从而影响用户体验。</p><p><img src="https://ae01.alicdn.com/kf/H8f802aef84a44c5a9809d1fa160cf8f8f.jpg" alt="model-component"></p><p><strong>可预测</strong></p><blockquote><p>跟随着 Flux、CQRS 和事件溯源的脚步，Redux 尝试通过在状态变更的时间和方式上强制施加一些限制，从而实现状态变更的可预测。<div style="text-align: right">——<a href="https://redux.js.org/introduction/motivation" target="_blank" rel="noopener">介绍 Redux：目的</a></div></p></blockquote><p>我们把前文所说的那些问题综合起来看就是 Redux 官方文档中说的<strong>状态变更时间和方式</strong>的<strong>不可预测性</strong>。如果能把状态数据<strong>何时改变</strong>和<strong>如何改变</strong>固定起来就好了。为了做到这一点， Redux 主要借鉴了 Facebook 在 2014 年推出的 Flux 架构。</p><h3 id="What-the-hell-is-Flux"><a href="#What-the-hell-is-Flux" class="headerlink" title="What the hell is Flux?"></a>What the hell is Flux?</h3><p>首先说明，Flux 不是框架，而是一种架构思想。但是因为 ，很容易出现前文提到过的那些问题，所以 Facebook 放弃了 MVC 架构，转而使用 Flux。实际上，Flux 是和 React 同时出现的，而 React 自己也采用了 Flux。Flux 最大特点就是数据的单向流动。它在模型和视图之间设置了一条<strong>单向轨道</strong>（如下）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">View</span><br><span class="line">-&gt; action -&gt; dispatcher -&gt; store -&gt; view</span><br><span class="line">-&gt; action -&gt; dispatcher -&gt; store -&gt; view</span><br><span class="line">-&gt; action -&gt; dispatcher -&gt; ..... -&gt; view</span><br></pre></td></tr></table></figure><p>或者你可以按照这张图理解：<br><img src="https://ae01.alicdn.com/kf/Had8f008ec7ce42a7ac55fde3635cf6afE.jpg" alt="Flux"></p><p>数据如果要从模型到达视图就必须经过 action、dispatcher、store 这几个部分。这条轨道是如何实现的呢？</p><p>Flux 中一切数据流动的起点是<code>action</code>（行动）。<code>action</code>是什么？就是一个对象而已。它有什么用呢？Flux 就是依靠识别不同的<code>action</code>决定该如何变更状态数据的，以此来固定状态变更的时间和方式。因此你可以把<code>action</code>理解成<strong>命令、指令</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    text: <span class="string">'Do something.'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 Facebook 官方的 <a href="https://github.com/redux-utilities/flux-standard-action#example" target="_blank" rel="noopener">Flux 标准 Action</a>，一个<code>action</code>对象必须是一个普通的 Javascript 对象，且必须包含一个名为<code>type</code>（类型）的属性，这个属性必须是一个普通的字符串，而这个<code>type</code>就是用来供 Flux 识别的<code>action</code>身份的。怎么识别呢？之后我们讲到 dispatcher 时再说。<code>action</code>还有一个重要属性：<code>payload</code>(其实还有两个可选属性<code>error</code>、<code>meta</code>，这里我们只讲<code>payload</code>)其中包含了某些状态变更函数所需的新数据。收到不同的 action 就会对应执行不同的状态变更的。</p><ul><li>一个对象：全局状态树让需要主动取用状态数据的组件可以直接访问到数据源，而不需要组件间数据的传递。</li><li>多个属性：状态数据</li><li>多个方法：<ul><li>:返回属性中的状态数据</li><li>emitChange：</li><li>changeData：实现数据变更所需的 callback 函数（How），之后每个 callback 会对应一个 action。</li><li>emitChange：通过 emitter 提交变更的函数。</li></ul></li></ul><h4 id="Dispatcher（分发器）"><a href="#Dispatcher（分发器）" class="headerlink" title="Dispatcher（分发器）"></a>Dispatcher（分发器）</h4><p>dispatcher.register: 参数是一个以 action 为参数的回调函数，这个函数用一个 switch 语句把所有可能用到的 store 中 callback 的调用规则按照不同的 action 类型组织起来。这个过程被称为 registration。可见 dispatcher 是任务分配的中心，你可以把它理解成十字路口的红绿灯。函数最后会调用 store 的 emitChange 方法，通知组件上的变化监听器，之后组件会做出相应的更新动作。dispatcher.dispatch 以 action 为参数，返回 store 中对应的 callback，之后直接可以拿到组建上使用。this.on(‘change’, ListStore.getAll()); 监听 dispatched action 引发的 store 的 emitChange 函数</p><iframe src="https://codesandbox.io/embed/flux-example-kp01g?fontsize=14" title="flux-example" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在 Redux，光听别人讲总觉得半懂不懂，也很难记住，干脆自己试着写篇东西梳理一下。但在学习 Redux 之前，我们有必要明白 Redux 是什么、有什么用。官方对于 Redux 的定义是个不错的入手点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSS筛选器Cheat Sheet</title>
    <link href="http://neo42.github.io/2019/08/16/2019-8-16-css-selector-cheat-sheet/"/>
    <id>http://neo42.github.io/2019/08/16/2019-8-16-css-selector-cheat-sheet/</id>
    <published>2019-08-16T04:37:00.000Z</published>
    <updated>2019-09-09T14:42:25.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MDN 常用 CSS 筛选器的总结。</p></blockquote><a id="more"></a><div class="table-container"><table><thead><tr><th>例子</th><th>描述</th></tr></thead><tbody><tr><td><code>h1</code></td><td>元素名称</td></tr><tr><td><code>#root</code></td><td><code>id</code></td></tr><tr><td><code>.container</code></td><td><code>class</code></td></tr><tr><td><code>button .info-button</code></td><td>带有 <code>class</code> 的元素</td></tr><tr><td><code>#root button</code></td><td><code>#root</code> 中的所有 <code>&lt;button&gt;</code></td></tr><tr><td><code>div,span</code></td><td>并列选择</td></tr><tr><td><code>*</code></td><td>所有元素</td></tr><tr><td><code>p *</code></td><td>所有 <code>&lt;p&gt;</code></td></tr><tr><td><code>p+div</code></td><td>紧跟在 <code>&lt;p&gt;</code> 后的 div</td></tr><tr><td><code>.title~p</code></td><td>.title 之后的所有同层级 <code>&lt;p&gt;</code></td></tr><tr><td><code>a&gt;b</code></td><td><code>&lt;a&gt;</code> 中的直接子元素 <code>&lt;b&gt;</code></td></tr><tr><td><code>div p</code></td><td>div 中的所有(直接或间接)<code>&lt;p&gt;</code></td></tr><tr><td><code>a:active</code></td><td>激活：Tab 键或鼠标左键交互时 包括但不限于<code>&lt;button&gt;&lt;a&gt;</code></td></tr><tr><td><code>input:checked</code></td><td>选项输入框被勾选时</td></tr><tr><td><code>input:default</code></td><td>表单默认值<code>&lt;button&gt;</code>、<code>&lt;input&gt;</code></td></tr><tr><td><code>input:disabled</code></td><td>被禁用时</td></tr><tr><td><code>div:empty</code></td><td>没有子元素时</td></tr><tr><td><code>p:first-child</code></td><td>所有 <code>&lt;p&gt;</code> 元素中身为其父元素的第一个子元素的元素 （而不是 p 中包含的第一个子元素）</td></tr><tr><td><code>p:first-of-type</code></td><td>同类元素中的第一个</td></tr><tr><td><code>input:focus</code></td><td>输入框被鼠标点中或者 tab 键</td></tr><tr><td><code>input:invalid</code></td><td>未通过验证的 <code>&lt;input&gt;</code> 或其他 <code>&lt;form&gt;</code> 元素</td></tr><tr><td><code>tr:nth-child(odd)/(even)</code></td><td>HTML 表格中的奇数/偶数行。</td></tr><tr><td><code>p:only-child</code></td><td><code>&lt;p&gt;</code> 中身为其父元素的唯一子元素的元素</td></tr><tr><td><code>input:required</code></td><td>带有 <code>required</code> 属性的表单元素</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;MDN 常用 CSS 筛选器的总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>在Github Page上部署Create React App</title>
    <link href="http://neo42.github.io/2019/08/07/2019-8-7-deploy-create-react-app/"/>
    <id>http://neo42.github.io/2019/08/07/2019-8-7-deploy-create-react-app/</id>
    <published>2019-08-07T14:57:00.000Z</published>
    <updated>2019-10-19T08:30:23.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习 React 时可以用 Github Pages 部署自己的小项目，所以稍微总结一下，方便以后参考。</p></blockquote><a id="more"></a><h2 id="添加主页"><a href="#添加主页" class="headerlink" title="添加主页"></a>添加主页</h2><p>在 package.json 中添加<code>homepage</code>属性</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"name": "My-CRA",</span><br><span class="line">"homepage": "https://neo42.github.io/mycra",</span><br><span class="line">"version": "0.1.0",</span><br></pre></td></tr></table></figure><h2 id="安装-gh-pages"><a href="#安装-gh-pages" class="headerlink" title="安装 gh-pages"></a>安装 gh-pages</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i gh-pages</span><br></pre></td></tr></table></figure><h2 id="部署脚本"><a href="#部署脚本" class="headerlink" title="部署脚本"></a>部署脚本</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts":&#123;</span><br><span class="line"> "predeploy": "npm run build",</span><br><span class="line"> "deploy": "gh-pages -d build",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行部署命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run deploy</span><br></pre></td></tr></table></figure><h2 id="提交一个-commit-到-repo"><a href="#提交一个-commit-到-repo" class="headerlink" title="提交一个 commit 到 repo"></a>提交一个 commit 到 repo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add . &amp;&amp; git commit -m <span class="string">"Deploy to Github Pages"</span> &amp;&amp; git push <span class="comment"># mac</span></span><br><span class="line">git add . | git commit -m <span class="string">"Deploy to Github Pages"</span> | git push <span class="comment"># windows</span></span><br></pre></td></tr></table></figure><h2 id="设置-Github-Pages-的源"><a href="#设置-Github-Pages-的源" class="headerlink" title="设置 Github Pages 的源"></a>设置 Github Pages 的源</h2><p>把 <code>source</code> 设置为 <code>gh-pages branch</code></p><p><img src="https://reactgo.com/static/f1b680b3a2d43d59ea55047e89a39948/74755/react-ghpages-setup.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习 React 时可以用 Github Pages 部署自己的小项目，所以稍微总结一下，方便以后参考。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>统计学基础简略梳理</title>
    <link href="http://neo42.github.io/2019/05/12/2019-5-12-statistics-1/"/>
    <id>http://neo42.github.io/2019/05/12/2019-5-12-statistics-1/</id>
    <published>2019-05-12T14:57:00.000Z</published>
    <updated>2019-09-24T16:59:40.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.khanacademy.org/math/ap-statistics" target="_blank" rel="noopener">Khan Academy AP®︎ Statistics</a> 的听课笔记。佛系解释，日后再改。</p></blockquote><a id="more"></a><p>假设要测量全国 N 人口身高，从中随机抽取 n 人</p><h2 id="总体-Population"><a href="#总体-Population" class="headerlink" title="总体 Population"></a>总体 Population</h2><p>全国 N 人</p><h2 id="样本-Sample"><a href="#样本-Sample" class="headerlink" title="样本 Sample"></a>样本 Sample</h2><script type="math/tex; mode=display">x_i</script><p>随机抽取的 n 人</p><script type="math/tex; mode=display">x_1,x_2,...,x_{n}</script><h2 id="总体均值-Population-Mean"><a href="#总体均值-Population-Mean" class="headerlink" title="总体均值 Population Mean"></a>总体均值 Population Mean</h2><p>全国 N 人的平均身高</p><script type="math/tex; mode=display">\mu=\dfrac{x_1+x_2+x_3+...+x_N}{N}=\dfrac{\sum_{i=1}^{N} x_i}{N}</script><h2 id="样本均值-Sample-Mean"><a href="#样本均值-Sample-Mean" class="headerlink" title="样本均值 Sample Mean"></a>样本均值 Sample Mean</h2><p>被抽取的 n 人的平均身高，n 人身高之和除以 n</p><script type="math/tex; mode=display">\overline{x}=\dfrac{x_1+x_2+x_3+...+x_n}{n}=\dfrac{\sum_{i=1}^{n} x_i}{n}</script><h2 id="（总体）方差-Population-Variance"><a href="#（总体）方差-Population-Variance" class="headerlink" title="（总体）方差 (Population) Variance"></a>（总体）方差 (Population) Variance</h2><p>反映<a href="#总体-population">总体</a>中各个数据与<a href="#总体均值-population-mean-mu">总体均值</a>的距离和数据的集中趋势，是为了方便描述数据特征而构造的的人造结构</p><script type="math/tex; mode=display">\sigma^2=\dfrac{(x_1-\mu)^2+(x_2-\mu)^2+(x_3-\mu)^2+...+(x_N-\mu)^2}{N}=\dfrac{\sum_{i=1}^{N}(x_i-\mu)^2}{N}</script><h2 id="推论统计学-Inferential-Statistics"><a href="#推论统计学-Inferential-Statistics" class="headerlink" title="推论统计学 Inferential Statistics"></a>推论统计学 Inferential Statistics</h2><p>根据对<a href="#样本-sample-x_i">样本</a>的描述推断<a href="#总体-population">总体</a>的情况</p><h2 id="样本方差-Sample-Variance"><a href="#样本方差-Sample-Variance" class="headerlink" title="样本方差 Sample Variance"></a>样本方差 Sample Variance</h2><p>与<a href="#总体方差-population-variance-sigma2">总体方差</a>同理，通常会小于总体方差</p><script type="math/tex; mode=display">S^2=\dfrac{(x_1-\overline{x})^2+(x_2-\overline{x})^2+(x_3-\overline{x})^2+...+(x_n-\overline{x})^2}{n}=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{n}</script><h2 id="总体方差的无偏估计-Unbiased-Estimate-of-The-Variance"><a href="#总体方差的无偏估计-Unbiased-Estimate-of-The-Variance" class="headerlink" title="总体方差的无偏估计 Unbiased Estimate of The Variance"></a>总体方差的无偏估计 Unbiased Estimate of The Variance</h2><p>一种更接近<a href="#总体方差-population-variance-sigma2">总体方差</a>的样本方差对总体方差的估计值</p><script type="math/tex; mode=display">S^2 =S_{n-1}^2=\dfrac{(x_1-\overline{x})^2+(x_2-\overline{x})^2+(x_3-\overline{x})^2+...+(x_n-\overline{x})^2}{n-1}=\dfrac{\sum_{i=1}^{n}(x_i-\overline{x})^2}{n-1}</script><h2 id="标准差-Standard-Deviation-sigma"><a href="#标准差-Standard-Deviation-sigma" class="headerlink" title="标准差 Standard Deviation $\sigma$"></a>标准差 Standard Deviation $\sigma$</h2><p><a href="#总体方差-population-variance-sigma2">方差</a>的平方根</p><script type="math/tex; mode=display">\sigma=\sqrt{\sigma^2}=\sqrt{\dfrac{\sum_{i=1}^{N}(x_i-\mu)^2}{N}}</script><h2 id="方差-sigma-2-公式的简化"><a href="#方差-sigma-2-公式的简化" class="headerlink" title="方差$\sigma^2$公式的简化"></a>方差$\sigma^2$公式的简化</h2><script type="math/tex; mode=display">\begin{align}\sigma^2 &= \dfrac{\sum_{i=1}^{N}(x_i-\mu)^2}{N}\\&= \dfrac{\sum_{i=1}^{N}(x_i^2-2x_i\mu+\mu^2)}{N}\\&= \dfrac{\sum_{i=1}^{N}x_i^2}{N}-2*\dfrac{\sum_{i=1}^{N}x_i}{N}*\mu+\dfrac{\sum_{i=1}^{N}\mu^2}{N}\\&= \dfrac{\sum_{i=1}^{N}x_i^2}{N}-2\mu^2+\mu^2\\&= \dfrac{\sum_{i=1}^{N}x_i^2}{N}-\mu^2\\&= \dfrac{\sum_{i=1}^{N}x_i^2}{N}-\dfrac{(\sum_{i=1}^{N}x_i)^2}{N^2}\\\end{align}</script><h2 id="随机过程-Random-Process"><a href="#随机过程-Random-Process" class="headerlink" title="随机过程 Random Process"></a>随机过程 Random Process</h2><p>简单理解：会发生一组随机事件的过程，例如抛硬币或者掷骰子</p><h2 id="输出值-Output"><a href="#输出值-Output" class="headerlink" title="输出值 Output"></a>输出值 Output</h2><p><a href="#随机过程-random-process">随机过程</a>中随机事件发生的结果，<a href="#随机变量-random-variable-x">随机变量</a>的取值</p><h2 id="随机变量-Random-Variable-X"><a href="#随机变量-Random-Variable-X" class="headerlink" title="随机变量 Random Variable $X$"></a>随机变量 Random Variable $X$</h2><p><a href="#随机过程-random-process">随机过程</a>中的随机事件结果集合，是用来量化随机过程的<strong>函数</strong>，从随机过程映射到数值</p><p>例如明天是否下雨</p><script type="math/tex; mode=display"> X=\begin{cases}  0, & \text{if it doesn't rain tomorrow}, \\  1, & \text{otherwise}.\end{cases}</script><p>或抛硬币哪面朝上</p><script type="math/tex; mode=display">X=\begin{cases}  0,&\text{if heads,}  \\  1,&\text{if tails.}\end{cases}</script><h2 id="离散型随机变量-Discrete-Random-Variable"><a href="#离散型随机变量-Discrete-Random-Variable" class="headerlink" title="离散型随机变量 Discrete Random Variable"></a>离散型随机变量 Discrete Random Variable</h2><p>数值个数有限、可以枚举、数值大小不连续</p><h2 id="连续型随机变量-Continuous-Random-Variable"><a href="#连续型随机变量-Continuous-Random-Variable" class="headerlink" title="连续型随机变量 Continuous Random Variable"></a>连续型随机变量 Continuous Random Variable</h2><p>无穷个数值、枚举无法覆盖全部情况、数值大小连续</p><h2 id="概率密度函数-Probability-Density-Function-f-x"><a href="#概率密度函数-Probability-Density-Function-f-x" class="headerlink" title="概率密度函数 Probability Density Function $f(x)$"></a>概率密度函数 Probability Density Function $f(x)$</h2><p>在数学中，<a href="#连续型随机变量-continuous-random-variable">连续型随机变量</a>的<a href="#概率密度函数-probability-density-function-fx">概率密度函数</a>是一个描述这个随机变量的输出值在某个确定的取值点附近的可能性的函数（不是概率大小，区别于<a href="#概率质量函数-probability-mass-function">概率质量函数</a>）。密度函数上单独的某一点表现的是概率质量函数在某一点的变化率。</p><p>图形示例</p><p><img src="/../density.png" alt="Image">{:.shadow}</p><p>构成过程：参考<a href="https://www.youtube.com/watch?v=flNS7ubhgTU" target="_blank" rel="noopener">YouTube</a></p><p><strong>概率大小和概率密度的关系</strong></p><ul><li>给定一个区间，则这个区间上概率密度函数的积分就是随机变量 X 落在这个区间内的概率</li></ul><script type="math/tex; mode=display">P(a \leq X \leq b)=\int_a^bf(X)d_x\\</script><ul><li>某点的 概率密度函数 即为 概率在该点的变化率(或导数).</li><li><a href="#随机过程-random-process">随机过程</a>中所有事件发生的概率之和（概率密度函数曲线下方的面积）为 1</li></ul><script type="math/tex; mode=display">\int_{-\infty}^\infty f(x)d_x=1</script><p>参考：<a href="https://www.zhihu.com/question/23237834" target="_blank" rel="noopener">知乎</a></p><h2 id="概率质量函数-Probability-Mass-Function"><a href="#概率质量函数-Probability-Mass-Function" class="headerlink" title="概率质量函数 Probability Mass Function"></a>概率质量函数 Probability Mass Function</h2><p><a href="#离散型随机变量-discrete-random-variable">离散随机变量</a>在各特定取值上的概率</p><p>概率质量函数和<a href="#概率密度函数-probability-density-function-fx">概率密度函数</a>不同之处在于：概率质量函数是对<a href="#离散型随机变量-discrete-random-variable">离散随机变量</a>定义的，本身代表该值的概率</p><h2 id="累积分布函数-Cumulative-Distribution-Function"><a href="#累积分布函数-Cumulative-Distribution-Function" class="headerlink" title="累积分布函数 Cumulative Distribution Function"></a>累积分布函数 Cumulative Distribution Function</h2><p>也叫概率分布函数、分布函数。是<a href="#概率密度函数-probability-density-function-fx">概率密度函数</a>的积分，概率函数取值的集合结果，表示离散变量中所有小于等于 a 的<a href="#输出值-output">输出值</a>出现概率的和</p><script type="math/tex; mode=display">{F_{X}(x)=\operatorname {P} (X\leq x)}</script><h2 id="期望值-Expected-Value-E-X"><a href="#期望值-Expected-Value-E-X" class="headerlink" title="期望值 Expected Value $E(X)$"></a>期望值 Expected Value $E(X)$</h2><p>总体均值、数学期望、或均值，亦简称期望</p><p><a href="#离散型随机变量-discrete-random-variable">离散性随机变量</a>的期望值是试验中每次可能的结果乘以其结果概率的总和</p><p>如果$X$是<a href="#离散型随机变量-discrete-random-variable">离散型随机变量</a>，输出值为 $x<em>{1},x</em>{2},\ldots$，和输出值相应的概率为 $p<em>{1},p</em>{2},\ldots$（概率和为 1）。</p><script type="math/tex; mode=display">{E} (X)=\sum _{i}p_{i}x_{i}</script><p>参考：<a href="https://zh.wikipedia.org/wiki/%E6%9C%9F%E6%9C%9B%E5%80%BC" target="_blank" rel="noopener">维基百科</a></p><h2 id="伯努利试验"><a href="#伯努利试验" class="headerlink" title="伯努利试验"></a>伯努利试验</h2><p>单次成功/失败试验又称为伯努利试验</p><h2 id="二项分布-Binomial-Distribution"><a href="#二项分布-Binomial-Distribution" class="headerlink" title="二项分布 Binomial Distribution"></a>二项分布 Binomial Distribution</h2><p>n 个独立的是/非试验中成功的次数的离散概率分布</p><h3 id="二项分布的概率"><a href="#二项分布的概率" class="headerlink" title="二项分布的概率"></a>二项分布的概率</h3><p>设进行 n 次<a href="#伯努利试验">伯努利试验</a>，结果为是的概率 P(是)=p，结果为非的概率 P(非)=1-p，结果为是次数为 k</p><p>结果为是次数为 k 的概率为</p><script type="math/tex; mode=display">  P(X=k)=  \Big(    \begin{split}    n \\    k    \end{split}  \Big)p^k(1-p)^{n-k};\Big(    \begin{split}    n \\    k    \end{split}  \Big)=\dfrac{N!}{k!(N-k)!}</script><p>n=1 时的二项分布称为伯努利分布</p><h3 id="二项分布的期望"><a href="#二项分布的期望" class="headerlink" title="二项分布的期望"></a>二项分布的期望</h3><p>设进行 n 次伯努利试验，结果为是的概率 P(是)=p，结果为否的概率 P(非)=1-p，结果为是次数为 k，$a = k-1,b = n-1,n-k = b-a$。总体<a href="#期望值-expected-value-ex">期望值</a>为</p><script type="math/tex; mode=display">\begin{align}E(X) &= \sum_{k=0}^nk\Big(     \begin{split}     n \\     k     \end{split}    \Big)p^k(1-p)^{n-k};\\    &= 0 + 1\Big(      \begin{split}        n\\        1      \end{split}      \Big)p^1(1-p)^{n-1} + ... +n\Big(      \begin{split}        n\\        n      \end{split}      \Big)p^n(1-p)^{n-n}\\    &= \sum_{k=1}^nk\Big(      \begin{split}        n\\        k      \end{split}      \Big)p^k(1-p)^{n-k}\\    &= \sum_{k=1}^nk\dfrac{n!}{k!(n-k)!}p^k(1-p)^{n-k}\\    &= \sum_{k=1}^nk\dfrac{n!}{k(k-1)!(n-k)!}p^k(1-p)^{n-k}\\    &= \sum_{k=1}^n\dfrac{n!}{(k-1)!(n-k)!}p^k(1-p)^{n-k}\\    &= \sum_{k=1}^n\dfrac{n(n-1)!}{(k-1)!(n-k)!}p*p^{k-1}(1-p)^{n-k}\\    &= np\sum_{k=1}^n\dfrac{(n-1)!}{(k-1)!(n-k)!}p^{k-1}(1-p)^{n-k}\\    &= np\sum_{a=0}^b\dfrac{b!}{a!(b-a)!}p^a(1-p)^{b-a}\\    &= np\sum_{a=0}^b\dfrac{b!}{a!(b-a)!}p^a(1-p)^{b-a}\\    &= np\sum_{a=0}^b\Big(      \begin{split}        b\\        a      \end{split}      \Big)p^a(1-p)^{b-a}\\    &= np    \end{align}</script><p>参考：<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E5%88%86%E4%BD%88" target="_blank" rel="noopener">维基百科</a></p><h2 id="泊松分布-Poisson-Distribution"><a href="#泊松分布-Poisson-Distribution" class="headerlink" title="泊松分布 Poisson Distribution"></a>泊松分布 Poisson Distribution</h2><p>一种离散分布，二项分布的极限</p><p>适合描述单位时间内随机事件发生的次数的概率分布。例：一段时间内一个路口的车流量、餐馆的就餐人数、汽车站台的候客人数、机器出现的故障数。</p><h3 id="泊松分布的概率质量函数"><a href="#泊松分布的概率质量函数" class="headerlink" title="泊松分布的概率质量函数"></a>泊松分布的概率质量函数</h3><p>$\lambda={某一随机事件在一段时间内发生的平均次数 \over 这段时间的长度}$ ，或者理解为期望值</p><script type="math/tex; mode=display">P(X=k)=\frac{e^{-\lambda}\lambda^k}{k!}</script><h4 id="推导-二项分布角度"><a href="#推导-二项分布角度" class="headerlink" title="推导(二项分布角度)"></a>推导(二项分布角度)</h4><script type="math/tex; mode=display">e=\lim_{n\to\infty}\left(1+{1 \over n}\right)^n\\</script><p>设${1 \over n}={a \over x},x=na,E(X) = \lambda = np$</p><script type="math/tex; mode=display">\begin{align}\lim_{n\to\infty}\left(1+{1 \over n}\right)^{na}&= \lim_{n\to\infty}\left(\left(1+{1 \over n}\right)^n\right)^a\\&= \lim_{n\to\infty}\left(\left(1+{1 \over n}\right)^n\right)^a\\&= \left(\lim_{n\to\infty}\left(1+{1 \over n}\right)^n\right)^a\\&= e^a\\\end{align}</script><p>当 n 趋于无穷时</p><script type="math/tex; mode=display">\begin{align}  \lim_{n\to\infty} P(X=k)&=\lim_{n\to\infty}{n \choose k} p^k (1-p)^{n-k} \\ &=\lim_{n\to\infty}{n! \over (n-k)!k!} \left({\lambda \over n}\right)^k \left(1-{\lambda\over n}\right)^{n-k}\\ &=\lim_{n\to\infty}{\left[\frac{n!}{n^k\left(n-k\right)!}\right]}\left(\frac{\lambda^k}{k!}\right){\left(1-\frac{\lambda}{n}\right)^n}{\left(1-\frac{\lambda}{n}\right)^{-k}}\\ &=\lim_{n\to\infty}\underbrace{\left[\frac{n(n-1)(n-2)...(n-k+1)}{n^k}\right]}_{\to 1}\left(\frac{\lambda^k}{k!}\right)\underbrace{\left(1-\frac{\lambda}{n}\right)^n}_{\to e^{-\lambda}}\underbrace{\left(1-\frac{\lambda}{n}\right)^{-k}}_{\to 1}\\&= \left(\frac{\lambda^k}{k!}\right)e^{-\lambda}\\\end{align}</script><h2 id="大数定律-Law-of-Larger-Numbers"><a href="#大数定律-Law-of-Larger-Numbers" class="headerlink" title="大数定律 Law of Larger Numbers"></a>大数定律 Law of Larger Numbers</h2><p>在重复试验中，随着试验次数的增加，事件发生的频率趋于一个稳定值。样本数量越多，则其算术平均值就有越高的概率接近期望值。</p><h2 id="正态分布-Normal-Distribution"><a href="#正态分布-Normal-Distribution" class="headerlink" title="正态分布 Normal Distribution"></a>正态分布 Normal Distribution</h2><p>一种离散型分布，泊松分布的极限</p><p>若随机变量服从一个数学期望为$μ$、方差为$σ^2$的正态分布，记为$X∼N(μ，σ2)$。其概率密度函数为</p><script type="math/tex; mode=display">f(x)=\frac{1}{\sqrt{2\pi}\cdot\sigma}e^{-\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^2}</script><ul><li>$\mu=0,\sigma=1$的正态分布是标准正态分布</li><li>使用正态分布近似代替二项分布时，必须进行连续性修正</li></ul><h2 id="Z-分数-Z-Score"><a href="#Z-分数-Z-Score" class="headerlink" title="Z 分数 Z-Score"></a>Z 分数 Z-Score</h2><p>表示给定值与平均值间距离多少个标准差</p><h2 id="经验法则-Empirical-Rule"><a href="#经验法则-Empirical-Rule" class="headerlink" title="经验法则 Empirical Rule"></a>经验法则 Empirical Rule</h2><p>又叫 3-sigma 法则或者 68-95-99.7 法则，用于对已知平均数和标准差的正态分布数据进行快速推算</p><p>在正态分布中，几乎所有数据都将落在均值的三倍标准差内。所述经验规则表明，68%的数据将分布在的第一个标准偏差之内，95%将落在第二个标准差之内，和 99.7%将落在均值的前三个标准偏差之内。</p><p>参考：<a href="https://baike.baidu.com/item/%E7%BB%8F%E9%AA%8C%E6%B3%95%E5%88%99%EF%BC%88%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%8E%9F%E7%90%86%EF%BC%89" target="_blank" rel="noopener">百度百科</a></p><h2 id="样本均值的抽样分布-Sampling-Distribution-of-the-Sample-Mean"><a href="#样本均值的抽样分布-Sampling-Distribution-of-the-Sample-Mean" class="headerlink" title="样本均值的抽样分布 Sampling Distribution of the Sample Mean"></a>样本均值的抽样分布 Sampling Distribution of the Sample Mean</h2><p>从原本的总体中取多个样本，对所有样本的样本均值进行抽样构成的频率分布。这个分布的均值与原总体均值相同。</p><h2 id="中心极限定理-The-Central-Limit-Theorem"><a href="#中心极限定理-The-Central-Limit-Theorem" class="headerlink" title="中心极限定理 The Central Limit Theorem"></a>中心极限定理 The Central Limit Theorem</h2><p>在适当的条件下，随机变量中的大量样本均值近似服从正态分布</p><h2 id="置信区间-Confidence-Intervals"><a href="#置信区间-Confidence-Intervals" class="headerlink" title="置信区间 Confidence Intervals"></a>置信区间 Confidence Intervals</h2><p>随机变量的样本均值分布中最常见的 95%的样本均值的范围</p><h2 id="偏度-Skew"><a href="#偏度-Skew" class="headerlink" title="偏度 Skew"></a>偏度 Skew</h2><p>正态分布的偏度为零，偏度为正的意味着右侧尾部较长（峰值偏小），为负意味着左侧尾部较长（峰值偏大）。</p><h2 id="峰度-Kurtosis"><a href="#峰度-Kurtosis" class="headerlink" title="峰度 Kurtosis"></a>峰度 Kurtosis</h2><p>峰度为正，峰值较尖，峰度为负，峰值较钝</p><p>样本容量越大，峰度和偏度越小，更接近正态分布，分布距离均值越近。</p><script type="math/tex; mode=display">lim_{1\to+\infty}P(|\frac{1}{n}\sum_i^nX_i-\mu|<\epsilon)=1, i=1,...,n</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.khanacademy.org/math/ap-statistics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Khan Academy AP®︎ Statistics&lt;/a&gt; 的听课笔记。佛系解释，日后再改。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
